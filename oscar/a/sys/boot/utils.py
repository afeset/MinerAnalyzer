# Copyright Qwilt, 2013
# 
# The code contained in this file may not be used by any other entities without explicit written permission from Qwilt.
# 
# Author: shmulika
import datetime
import distutils.dir_util
import os
import shutil
import subprocess as originalsubprocess


import a.infra.format.json
import a.infra.process
import a.infra.subprocess

import a.sys.firmware.bios
import a.sys.secure_digital.utils


# Bypass for PyChecker
if  __package__ is None:
    G_MODULE_NAME_BOOT                        = "unknown"
    G_GROUP_NAME_BOOT_UTILS                   = "unknown"
else:
    from . import G_MODULE_NAME_BOOT      
    from . import G_GROUP_NAME_BOOT_UTILS 


grubConfHeaderText = """
# grub.conf generated by %(creator)s at %(creation-date-utc)s
#
#                                                                                        
# Note that you do not have to rerun grub after making changes to this file              
# NOTICE:  You have a /boot partition.  This means that                                  
#          all kernel and initrd paths are relative to /boot/, eg.                       
#          root (hd0,0)
#          kernel /vmlinuz-version ro root=LABEL=sd-main
#          initrd /initrd-[generic-]version.img
default=%(default-option)s
timeout=15
"""


class BootUtilsError(Exception):
    def __init__ (self, msg):
        Exception.__init__(self, msg)



class BootUtils(object):
    """ TODO(shmulika): doc this!

    Notice this class is also used by Pilot (via PilotServices), and thus is responsbile for maitaining backward-compatability.
    For this reason - Pilot has its own Interface methods, which are the methods that must maintain backward-compatability for Pilot.
    """    
    
    #initialization fields
    INIT_PARAM_DATA_OSCAR_BOOT_OPTIONS_FILE = "oscar-boot-options-file"
    INIT_PARAM_DATA_KRUSTY_FILE_SUFFIX      = "krusty-file-suffix"

    _INIT_PARAM_FILE_NAME = "sys-boot-utils-init-params.json"    

    #osef key
    _OSEF_KEY = "sys-boot-utils"

    DEAFULT_KILL_TIMEOUT    = 100
    DEAFULT_WARNING_TIMEOUT = 50


#-----------------------------------------------------------------------------#

    ######################################
    # INITIALIZATION INTERFACE
    ######################################

    def __init__ (self, logger):
        self._log = logger.createLoggerSameModule(G_GROUP_NAME_BOOT_UTILS)


    def init (self, oscarBootOptionsFilePath, krustyJsonFilePathSuffix, sdUtils = None, platformBasic = None):
        self._oscarBootOptionsFilePath  = oscarBootOptionsFilePath
        self._krustyJsonFilePathSuffix        = krustyJsonFilePathSuffix
        self._allowBootSettings = True

        if platformBasic is not None:
            self._log("init").notice("configured to use a given platform-basic")
            self._platformBasic = platformBasic
            self._allowBootSettings = False # do not allow to set/get the system's boot settings when inited for probably other platforms
        else:
            self._platformBasic = a.infra.process.getPlatformBasicDataOrCrash()

        if sdUtils is not None:
            self._log("init").notice("configured to use a given sd-utils")
            self._sdUtils = sdUtils
            self._allowBootSettings = False # do not allow to set/get the system's boot settings when inited for probably external Secure Digital
        else:
            self._sdUtils = a.sys.secure_digital.utils.SdUtils(self._log)
        
    ###########################################
    # CAPTAIN CLIENT INITIALIZATION INTERFACE
    ##########################################

    def initCaptain (self, captain):
        """ set the captain object used by the class
        """
        self._captain = captain

    def initFromDictionary (self, data):
        """ Initializes using a dictionary. see "init" for more details
        """
        return self.init(oscarBootOptionsFilePath = data[self.INIT_PARAM_DATA_OSCAR_BOOT_OPTIONS_FILE],
                         krustyJsonFilePathSuffix = data[self.INIT_PARAM_DATA_KRUSTY_FILE_SUFFIX])   

    def captainClient_initFromParamFile (self):
        """ Initializes the platform_basic directory from which all the platform data is loaded, and the platform type
        Fatal in case of failure
        """

        initParamFilesDirName = self._captain.getInitParamFilesDirName()
        initParamFileName = os.path.join(initParamFilesDirName, self._INIT_PARAM_FILE_NAME)
        try:
            if os.path.exists(initParamFileName):
                self._log("read-init-file").debug2("reading init file %s", initParamFileName)
                data = a.infra.format.json.readFromFile(self._log, initParamFileName)
            else:
                a.infra.process.processFatal("Failed to init boot utils. File %s does not exists", initParamFileName)

        except Exception as exception:
            a.infra.process.processFatal("Failed to read boot utils init file: %s", exception)

        self._log("init-values").debug2("Init values: '%s'", data)

        try:
            self.initFromDictionary(data)
        except Exception as exception:
            a.infra.process.processFatal("Failed to init boot utils: %s", exception)


    def captainClient_addToOsef (self):
        self._log("add-to-osef").debug2("adding to osef: %s", self._OSEF_KEY)
        self._captain.getOsef()[self._OSEF_KEY] = self


    ######################################
    # GETTERS INTERFACE
    ######################################
    
    def createBootUtilsForExternalSecureDigital (self, sdUtils, platformBasic):
        """ creates a boot-utils to enable writing and setting grub (boot installation) on an external secure digital
        sdUtils       - the sd-utils to access the external SD
        platformBasic - according to the platform type the SD is intedned for
        """
        newBootUtils = BootUtils(self._log)
        newBootUtils.init(self._oscarBootOptionsFilePath, self._krustyJsonFilePathSuffix, sdUtils, platformBasic)
        return newBootUtils

#-----------------------------------------------------------------------------#

    ######################################
    # GETTERS INTERFACE
    ######################################

    def getSystemDiskBootDevice (self):
        self._assertAllowBootSettings()
        systemDiskBootDevice = self._platformBasic.getDiskProperty(self._platformBasic.DISK_NAME_SYS_BOOT,  self._platformBasic.DISK_FIELD_OS_DEVICE)
        self._log("get-system-disk-boot-device").notice("return: systemDiskBootDevice=%s", systemDiskBootDevice)
        return systemDiskBootDevice


    def getSdGrubDirectoryPath (self):
        bootMount = self._sdUtils.getBootPartitionMountPoint()
        grubDirPath = os.path.join(bootMount, "grub")
        self._log("get-sd-grub-conf-path").notice("return: sd grub directory path=%s", grubDirPath)
        return grubDirPath


    def getSdGrubConfPath (self):
        bootMount = self._sdUtils.getBootPartitionMountPoint()
        grubConfPath = os.path.join(bootMount, "grub", "grub.conf")
        self._log("get-sd-grub-conf-path").notice("return: sd grub.conf path=%s", grubConfPath)
        return grubConfPath


    def getSdGrubStage2Path (self):
        bootMount = self._sdUtils.getBootPartitionMountPoint()
        grubStage2Path = os.path.join(bootMount, "grub", "stage2")
        self._log("get-sd-grub-stage2").notice("return: sd grub stage2 path=%s", grubStage2Path)
        return grubStage2Path

    def getSdDeviceMapPath (self):
        bootMount = self._sdUtils.getBootPartitionMountPoint()
        deviceMapPath = os.path.join(bootMount, "grub", "device.map")
        self._log("get-sd-device-map").notice("return: sd device map path=%s", deviceMapPath)
        return deviceMapPath



#-----------------------------------------------------------------------------#

    ######################################
    # FUNCTIONALITY INTERFACE
    ######################################

    def setBootFromSystemDisk (self):
        self._assertAllowBootSettings()

        if not a.sys.firmware.bios.BiosConfig.s_canSetBootDevice(self._log, self._platformBasic):
            self._log("set-boot-frod-system-disk").notice("setting boot device is not supported on this platform. ignoring.")
            return

        self.isSecureDigialBootDevice() # this is for log, we want boot device to show before and after setting

        if not a.sys.firmware.bios.BiosConfig.s_setBootDeviceSystemDisk(self._log, self._platformBasic):
            msg = "failed setting system disk as boot device"
            self._log("set-boot-frod-system-disk").notice(msg)
            raise BootUtilsError(msg)

        self.isSecureDigialBootDevice() # this is for log, we want boot device to show before and after setting

        self._log("set-boot-frod-system-disk").notice("boot device was set to system disk")


    def setBootFromSd (self):
        self._assertAllowBootSettings()

        if not a.sys.firmware.bios.BiosConfig.s_canSetBootDevice(self._log, self._platformBasic):
            self._log("set-boot-frod-system-disk").notice("setting boot device is not supported on this platform. ignoring.")
            return

        self.isSecureDigialBootDevice() # this is for log, we want boot device to show before and after setting

        if not a.sys.firmware.bios.BiosConfig.s_setBootDeviceSd(self._log, self._platformBasic):
            msg = "failed setting secure digital as boot device"
            self._log("set-boot-frod-sd").notice(msg)
            raise BootUtilsError(msg)

        self.isSecureDigialBootDevice() # this is for log, we want boot device to show before and after setting

        self._log("set-boot-frod-sd").notice("boot device was set to secure digital")


    def isSecureDigialBootDevice (self):        
        self._assertAllowBootSettings()

        isSdBootDevice = a.sys.firmware.bios.BiosConfig.s_getIsSdConfiguredBootDevice(self._log, self._platformBasic)
        self._log("is-secure-digital-boot-device").notice("is secure digital boot device: %s", isSdBootDevice)
        return isSdBootDevice


    def isSystemDiskBootDevice (self):
        self._assertAllowBootSettings()

        return not self.isSecureDigialBootDevice()


    def isBootDeviceSettable (self):
        """ Returns True if the boot device can be set programatically in running platform.
        """
        self._assertAllowBootSettings()

        isSettable = a.sys.firmware.bios.BiosConfig.s_canSetBootDevice(self._log, self._platformBasic)
        self._log("is-boot-device-settable").notice("is boot device settable: %s", isSettable)
        return isSettable


    def updateSecureDigitalGrubConf (self, allowKrustyBootOptions, defaultBootOptionTag = None, bootOnce = False, allowOscarBootOptions = True):        
        self._log("update-secure-digital-grub-conf").notice("updating secure digital grub conf (with-krusty-options=%s):", allowKrustyBootOptions)
        oscarBootOptionsFilePath = self._oscarBootOptionsFilePath
        grubConfText, bootOptions, defaultOptionIndex = self._createGrubConf(oscarBootOptionsFilePath, allowKrustyBootOptions, defaultBootOptionTag, defaultSavedMode = True, allowOscarBootOptions = allowOscarBootOptions)
        grubConfPath = self.getSdGrubConfPath()
        self._log("update-secure-digital-grub-conf").notice("updating file %s, with content:\n%s", grubConfPath, grubConfText)
        self._writeTextToSecureDigitalFile(grubConfText, grubConfPath)
        self.setSecureDigitalDefaultBootOption(defaultOptionIndex, bootOnce = bootOnce)


    def updateSecureDigitalGrubConfOriginal (self, allowKrustyBootOptions, defaultBootOptionTag = None, allowOscarBootOptions = True):        
        self._log("update-secure-digital-grub-conf").notice("updating secure digital grub conf (with-krusty-options=%s):", allowKrustyBootOptions)
        oscarBootOptionsFilePath = self._oscarBootOptionsFilePath
        grubConfText, bootOptions, defaultOptionIndex = self._createGrubConf(oscarBootOptionsFilePath, allowKrustyBootOptions, defaultBootOptionTag, defaultSavedMode = False, allowOscarBootOptions = allowOscarBootOptions)
        grubConfPath = self.getSdGrubConfPath() + ".orig"
        self._log("update-secure-digital-grub-conf").notice("updating file %s, with content:\n%s", grubConfPath, grubConfText)
        self._writeTextToSecureDigitalFile(grubConfText, grubConfPath)


    def setSecureDigitalDefaultBootOption (self, bootOptionIndex, bootOnce = False):
        self._setDefaultBootOptionIndex(self.getSdGrubStage2Path(), bootOptionIndex, bootOnce = bootOnce)
        

    def installSecureDigitalGrub (self):
        self._log("install-secure-digital-grub").notice("About to install grub on the SD's boot partition:")
        self._sdUtils.mountBootPartition()        
        grubDir = self.getSdGrubDirectoryPath()
                
        sourceGrubDirectory = "/boot/grub" # the grub directory of the system disk (source for files to be copied to secure digital)
        distutils.dir_util.copy_tree(sourceGrubDirectory, grubDir)
        self._writeSecureDigitalDeviceMapFile()        
        self._runCommandRaiseIfFail("sync", killTimeout = 900)
        grubInput = "root (hd0,0)\nsetup  --stage2=%s --prefix=/grub (hd0)\nquit\n" % (self.getSdGrubStage2Path())
        self._log("install-secure-digital-grub").notice("running 'grub --batch' with input='%s'" % (grubInput))
        self._runCommandRaiseIfFail("grub --batch --device-map=%s" % self.getSdDeviceMapPath(), input=grubInput, killTimeout = 240)
        self._runCommandRaiseIfFail("sync", killTimeout = 900)

        self._writeSecureDigitalDeviceMapFile(invalid = True)

        self._log("install-secure-digital-grub").notice("Succesfuly installed grub on the SD's boot partition.")

#-----------------------------------------------------------------------------#

    ###################################################################################
    # PILOT INTERFACE
    # 
    # Important Note:
    #    This interface must always remain backward compatible,
    #    since there is no strict correspondence between Pilot version & Oscar version.
    #    All pilots must see the same backward-compatible API,
    #    The API can only be expanded - never changed!
    #    If SdUtils functionality is changed, this interface must wrap it and
    #    preserve backward compatability.
    ###################################################################################


    def pilotWriteSecureDigitalGrubConfNext (self):
        """ Creates a grub.conf.next file and writes it to the secure digital's boot partition.
        It reads Oscar's grub boot options file that was written by Pilot, and add's Krusty's boot options, to create the entire content.
        """
        self._assertAllowBootSettings()
        self._log("pilot-write-secure-digital-grub-conf-next").notice("writing secure digital grub conf next:")
        oscarBootOptionsFilePath = self._oscarBootOptionsFilePath + ".next"
        grubConfText, bootOptions, defaultOptionIndex = self._createGrubConf(oscarBootOptionsFilePath)
        grubConfNextPath = self.getSdGrubConfPath() + ".next"
        self._log("pilot-write-secure-digital-grub-conf-next").notice("updating file %s, with content:\n%s", grubConfNextPath, grubConfText)
        self._writeTextToSecureDigitalFile(grubConfText, grubConfNextPath)


    def pilotGetSecureDigitalGrubConfPath (self):
        """ Returns the path to the SD's grub.conf file.
        Pilots writes the contents created by pilotCreateSdGrubConf() to this file during the final switch script.
        Pilot must also make sure that the SD boot partition is mounted, before doing so during the switch script.
        """
        self._assertAllowBootSettings()
        return self.getSdGrubConfPath()


    def pilotGetSecureDigitalGrubStage2Path (self):
        """ Returns the path to the SD's grub stage2 file.
        """
        self._assertAllowBootSettings()
        return self.getSdGrubStage2Path()


    def pilotGetSecureDigitalGrubDirectoryPath (self):
        """ Returns the path to the SD's grub stage2 file.
        """
        self._assertAllowBootSettings()
        return self.getSdGrubDirectoryPath()


    def pilotGetSecureDigitalDefaultBootOptionIndex (self):
        """ Returns the index of the default boot option which Pilot should set grub to
        """
        self._assertAllowBootSettings()
        return 0


    def pilotGetSystemDiskBootDevice (self):
        """ Returns the os-device of the system disk boot partition.
        """
        self._assertAllowBootSettings()
        return self.getSystemDiskBootDevice()


    def pilotGetSdBootDeivce (self):
        """ Returns the os-device of the sd's boot partition.
        """
        self._assertAllowBootSettings()
        return self._sdUtils.getBootPartitionDevice()


    def pilotIsSdBootDevice (self):
        """ Returns True if the SD is the boot device
        """
        self._assertAllowBootSettings()
        return self.isSecureDigialBootDevice()
        

    def pilotIsBootDeviceSettable (self):
        """ Returns True if the boot device can be set programatically in running platform.
        """
        self._assertAllowBootSettings()
        return self.isBootDeviceSettable()


    def pilotIsSystemDiskBootDevice (self):
        """ Returns True if the system disk is the boot device
        """
        # TODO(shmulika): integrate with nirs code, that checks BIOS, meanwhile replacement code
        self._assertAllowBootSettings()
        return not self.pilotIsSdBootDevice() 
    
#-----------------------------------------------------------------------------#

    ###############################################
    # STATIC METHODS
    ###############################################
    @classmethod
    def s_getFromOsefUnsafe (cls, osef):
        if not cls._OSEF_KEY in osef:
            return None
        return osef[cls._OSEF_KEY]

    @classmethod
    def s_getFromOsefOrCrash (cls, osef):
        obj = cls.s_getFromOsefUnsafe(osef)
        if obj is None:
            a.infra.process.processFatal("Failed to bring boot utils from osef")
        return obj

    @classmethod
    def s_createInitParamFile (cls, dbgLog, initParamFilesDirName,  dictionary):
        a.infra.format.json.writeToFile(dbgLog, dictionary, os.path.join(initParamFilesDirName, cls._INIT_PARAM_FILE_NAME), indent=4)

#-----------------------------------------------------------------------------#

    ######################################
    # LOGIC METHODS PRIVATE
    ######################################

    def _assertAllowBootSettings (self):
        if not self._allowBootSettings:
            self._log("assert-allow-boot-settings").error("Boot settings (get/set) is not allowed, cannot continue.")
            raise BootUtilsError("Boot settings is not allowed")
        self._log("assert-allow-boot-settings").debug1("Boot settings (get/set) is allowed.")


    def _writeSecureDigitalDeviceMapFile (self, invalid = False):
        """ When invalid is True, the file written is invalid by purpose.
        """
        deviceMapFile = self.getSdDeviceMapPath()
        sdDevice = self._sdUtils.getSdDevice()

        if not invalid:
            deviceMapText = "# this device map was generated by QB's sd-manager\n(hd0)     %s\n" % sdDevice
        else:
            deviceMapText = "# this invalid device map was generated by QB's sd-manager\nInvalid, while installing was: (hd0)     %s\n" % sdDevice

        self._log("write-secure-digital-device-map-file").notice("writing device.map content to file=%s, content=%s", deviceMapFile, deviceMapText)
        with open(deviceMapFile, "w") as fileOut:
            fileOut.write(deviceMapText)


    def _setDefaultBootOptionIndex (self, stage2Path, bootOptionIndex, bootOnce = False):
        self._log("set-default-boot-option-index").notice("_setDefaultBootOptionIndex(stage2Path=%s, bootOptionIndex=%s, bootOnce=%s) setting default boot option: " % (stage2Path, bootOptionIndex, bootOnce))
        if bootOnce:
            grubInput = "savedefault --stage2=%s --default=%s --once\n" % (stage2Path, bootOptionIndex)
        else:
            grubInput = "savedefault --stage2=%s --default=%s\n" % (stage2Path, bootOptionIndex)

        self._writeSecureDigitalDeviceMapFile()
        self._log("set-default-boot-option-index").notice("running 'grub --batch' with input='%s'" % (grubInput))
        # removed this sync command, because it happens while Oscar is running,
        # we saw once that sync while Oscar is busy with traffic (probably acquisition mostly? maybe other) might block for 8 minutes!
        #self._runCommandRaiseIfFail("sync", killTimeout = 900)
        self._runCommandRaiseIfFail("grub --batch --device-map=%s" % self.getSdDeviceMapPath(), input=grubInput, killTimeout = 240)
        self._writeSecureDigitalDeviceMapFile(invalid = True)


    def _createGrubConf (self, oscarBootOptionsFile, allowKrustyBootOptions = True, defaultBootOptionTag = None, defaultSavedMode = False, allowOscarBootOptions = True):
        self._log("create-grub-conf").notice("_createGrubConf(oscarBootOptionsFile=%s, allowKrustyBootOptions=%s, defaultBootOptionTag=%s, defaultSavedMode=%s, allowOscarBootOptions=%s) called." % (oscarBootOptionsFile, allowKrustyBootOptions, defaultBootOptionTag, defaultSavedMode, allowOscarBootOptions))
        krustyBootOptions = []
        if allowKrustyBootOptions and self._sdUtils.isKrustyValid():
            krustyBootOptions = self._readKrustyBootOptions()

        oscarBootOptions = []
        if allowOscarBootOptions:
            oscarBootOptions = self._readOscarBootOptions(oscarBootOptionsFile)

        bootOptions = self._mergeBootOptions([oscarBootOptions, krustyBootOptions])

        grubConfText, defaultOptionIndex = self._bootOptionsToGrubConfText(bootOptions, defaultBootOptionTag, defaultSavedMode)
        return (grubConfText, self._createBootOptionsDictionary(bootOptions), defaultOptionIndex)


    def _createBootOptionsDictionary (self, bootOptions):
        dictionary = self._createCreationDictionary()
        dictionary["grub-options"] = bootOptions
        return dictionary

        
    def _readOscarBootOptions (self, filepath):
        oscarBootOptionsDictionary = a.infra.format.json.readFromFile(self._log, filepath)
        return oscarBootOptionsDictionary["grub-options"]
        

    def _readKrustyBootOptions (self):        
        self._sdUtils.mountMainPartition()
        krustyInfoFile = os.path.join(self._sdUtils.getMainPartitionMountPoint(), self._krustyJsonFilePathSuffix)
        krustyInfo = a.infra.format.json.readFromFile(self._log, krustyInfoFile)        
        return krustyInfo["platform"][self._platformBasic.getPlatformType()]["grub-options"]


    def _mergeBootOptions (self, listBootOptions):
        mergedBootOptions = []
        for bootOptions in listBootOptions:
            mergedBootOptions.extend(bootOptions)

        return mergedBootOptions


    def _bootOptionsToGrubConfText (self, bootOptions, defaultBootOptionTag, defaultSavedMode):
        self._log("boot-options-to-grub-conf-text").notice("creating grub.conf text from bootOptions=%s, defaultBootOptionTag=%s, defaultSavedMode=%s", bootOptions, defaultBootOptionTag, defaultSavedMode)
        
        defaultOption = 0
        if defaultBootOptionTag is not None:
            bootOptionTagFound = False
            for bootOption, bootIndex in zip(bootOptions, xrange(len(bootOptions))):
                if bootOption["tag"] == defaultBootOptionTag:
                    defaultOption = bootIndex
                    bootOptionTagFound = True

            if not bootOptionTagFound:
                msg = "cannot find boot option with tag %s, cannot continue" % defaultBootOptionTag
                self._log("create-grub-conf-text").notice(msg)
                raise BootUtilsError(msg)

        grubParams = self._createCreationDictionary()
        if defaultSavedMode:
            grubParams["default-option"] = "saved"
        else:
            grubParams["default-option"] = str(defaultOption)
        lines = [grubConfHeaderText % grubParams]
        
        for bootOption in bootOptions:
            lines.append(bootOption["title"])
            lines.extend(bootOption["text"])
            lines.append("\n")

        grubConfText = "\n".join(lines)
        self._log("boot-options-to-grub-conf-text").notice("created grub.conf text:\n%s", grubConfText)

        return (grubConfText, defaultOption)


    def _createCreationDictionary (self):
        oscarVersionString = self._getOscarVersionString()
        dateTime           = datetime.datetime.utcnow().strftime("%Y%m%d-%H%M%S")

        return {"creator"           : oscarVersionString,
                "creation-date-utc" : dateTime}


    def _getOscarVersionString (self):
        oscarVersion = a.infra.process.getApplicationVersionUnsafe()
        if oscarVersion is None:
            oscarVersion = "unknown"
        oscarVersionString = "Oscar-%s" % oscarVersion
        return oscarVersionString


    def _writeTextToSecureDigitalFile (self, text, filePath):
        self._sdUtils.mountBootPartition()
        tempFilePath = filePath + ".tmp"
        with open(tempFilePath, "w") as fileOut:
            fileOut.write(text)

        shutil.move(tempFilePath, filePath)

# TODO(shmulika): 18/4/2013 - remove this after compile+testing, make sure not needed by anythin (doesn't seem to be)
#    def _writeDictionaryAsJson (self, dictionary, filename):
#        self._sdUtils.mountBootPartition()
#        a.infra.format.json.writeToFile(self._log, dictionary, filename, indent=4)
#
#
#    def _readDictionaryFromJson (self, filename):
#        self._sdUtils.mountBootPartition()
#        return a.infra.format.json.readFromFile(self._log, filename)


    def _runCommand (self, cmd, killTimeout = DEAFULT_KILL_TIMEOUT, warningTimeout = DEAFULT_WARNING_TIMEOUT, shell = False, input = None):
        subprocess = a.infra.subprocess.Subprocess("boot-utils", self._log)
        args = cmd
        if not shell:
            args = cmd.split()

        try:
            self._log("run-command").notice("running command, args=%s, input=%s", args, input)

            if input is None:
                stdin = None
            else:
                stdin = originalsubprocess.PIPE

            subprocess.start(args, stdin = stdin, stdout = originalsubprocess.PIPE, stderr = originalsubprocess.PIPE, shell = shell)
            omreportStdout, omreportStderr = subprocess.communicate(input = input, killTimeOut = killTimeout, warningTimeOut = warningTimeout)
            self._log("run-command").notice("command stdout = %s, stderr = %s", omreportStdout, omreportStderr)
        except Exception as exception:
            self._log("run-command").error("Failed executing cmd %s, error=%s", args, exception, exc_info = 1)
            return (1, "", "")

        returnCode = subprocess.getReturnCode()                
        self._log("run-command").notice("command rc = %s", returnCode)
        return (returnCode, omreportStdout, omreportStderr)


    def _runCommandRaiseIfFail (self, command, killTimeout = DEAFULT_KILL_TIMEOUT, warningTimeout = DEAFULT_WARNING_TIMEOUT, shell=False, input = None):
        """Returns a tuple (outText,errText)"""
        (rc,outText,errText) = self._runCommand(command, killTimeout = killTimeout, warningTimeout = warningTimeout, shell = shell, input = input)
        if rc != 0:            
            self._log("run-command-raising").warning("Command returned '%s', raising exception", rc)
            raise BootUtilsError("Failed running command %s" % command)
        return (outText,errText)




